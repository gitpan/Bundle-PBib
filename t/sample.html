<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE>BEACH Application Model and Software Framework</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.1.3  (Win32)">
	<META NAME="AUTHOR" CONTENT="Peter Tandler">
	<META NAME="CREATED" CONTENT="20041130;13260000">
	<META NAME="CHANGEDBY" CONTENT="Peter Tandler">
	<META NAME="CHANGED" CONTENT="20041130;17282428">
	<META NAME="CLASSIFICATION" CONTENT="JSS special issue on UbiTools">
	<STYLE>
	<!--
		@page { size: 21cm 29.7cm; margin-right: 3.18cm; margin-top: 2.54cm; margin-bottom: 1.27cm }
		P { margin-bottom: 0.21cm; direction: ltr; color: #000000; text-align: justify; widows: 2; orphans: 2 }
		P.western { font-family: "Times New Roman", serif; font-size: 10pt; so-language: en-US }
		P.cjk { font-family: "Times New Roman", serif; font-size: 10pt }
		P.ctl { font-family: "Times New Roman", serif; font-size: 10pt; so-language: ar-SA }
		H1 { margin-bottom: 0.42cm; direction: ltr; color: #000000; text-align: left; page-break-inside: avoid; widows: 2; orphans: 2 }
		H1.western { font-family: "Arial", sans-serif; font-size: 14pt; so-language: en-US; font-weight: medium }
		H1.cjk { font-family: "Times New Roman", serif; font-size: 14pt; font-weight: medium }
		H1.ctl { font-family: "Times New Roman", serif; font-size: 10pt; so-language: ar-SA; font-weight: medium }
		H2 { margin-top: 0.21cm; margin-bottom: 0.11cm; direction: ltr; color: #000000; text-align: left; page-break-inside: avoid; widows: 2; orphans: 2 }
		H2.western { font-family: "Arial", sans-serif; font-size: 11pt; so-language: en-US; font-weight: medium }
		H2.cjk { font-family: "Times New Roman", serif; font-size: 11pt; font-weight: medium }
		H2.ctl { font-family: "Times New Roman", serif; font-size: 10pt; so-language: ar-SA; font-weight: medium }
		H3 { margin-top: 0.21cm; margin-bottom: 0.11cm; direction: ltr; color: #000000; text-align: left; widows: 2; orphans: 2 }
		H3.western { font-family: "Arial", sans-serif; font-size: 11pt; so-language: en-US; font-weight: medium }
		H3.cjk { font-family: "Times New Roman", serif; font-size: 11pt; font-weight: medium }
		H3.ctl { font-family: "Times New Roman", serif; font-size: 10pt; so-language: ar-SA; font-weight: medium }
		P.sdfootnote-western { margin-left: 0.25cm; text-indent: -0.25cm; margin-bottom: 0.14cm; font-family: "Times New Roman", serif; font-size: 10pt; so-language: en-US }
		P.sdfootnote-cjk { margin-left: 0.25cm; text-indent: -0.25cm; margin-bottom: 0.14cm; font-family: "Times New Roman", serif; font-size: 10pt }
		P.sdfootnote-ctl { margin-left: 0.25cm; text-indent: -0.25cm; margin-bottom: 0.14cm; font-family: "Times New Roman", serif; font-size: 10pt; so-language: ar-SA }
		H1.heading-1*-western { font-family: "Arial", sans-serif; font-size: 14pt; so-language: en-US; font-weight: medium }
		H1.heading-1*-cjk { font-family: "Times New Roman", serif; font-size: 14pt; font-weight: medium }
		H1.heading-1*-ctl { font-family: "Times New Roman", serif; font-size: 10pt; so-language: ar-SA; font-weight: medium }
		H2.heading-2*-western { margin-left: 1.02cm; text-indent: -1.02cm; font-family: "Arial", sans-serif; font-size: 11pt; so-language: en-US; font-weight: medium }
		H2.heading-2*-cjk { margin-left: 1.02cm; text-indent: -1.02cm; font-family: "Times New Roman", serif; font-size: 11pt; font-weight: medium }
		H2.heading-2*-ctl { margin-left: 1.02cm; text-indent: -1.02cm; font-family: "Times New Roman", serif; font-size: 10pt; so-language: ar-SA; font-weight: medium }
		A:link { color: #000000; text-decoration: none }
		A.western:link { font-style: italic }
		A.cjk:link { font-style: italic }
		A:visited { color: #800080 }
		A.sdfootnoteanc { font-size: 57% }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" TEXT="#000000" LINK="#000000" VLINK="#800080" DIR="LTR">
<P ALIGN=LEFT STYLE="margin-top: 0.42cm; margin-bottom: 0.42cm; page-break-inside: avoid; page-break-before: always; page-break-after: avoid">
<FONT FACE="Arial, sans-serif"><FONT SIZE=4 STYLE="font-size: 16pt"><B>The
BEACH Application Model and Software Framework for Synchronous
Collaboration in Ubiquitous Computing Environments</B></FONT></FONT></P>
<P STYLE="margin-top: 0.21cm; page-break-inside: avoid; page-break-after: avoid">
<FONT FACE="Arial, sans-serif"><FONT SIZE=3>Peter Tandler</FONT></FONT></P>
<P LANG="" ALIGN=LEFT STYLE="margin-bottom: 0.64cm; page-break-inside: avoid; widows: 0; orphans: 0; page-break-after: avoid">
<FONT FACE="Times, serif">FhG &ndash; Fraunhofer Gesellschaft
e.V.<BR>IPSI &ndash; Integrated Publication and Information Systems
Institute<BR>AMBIENTE &ndash; Workspaces of the
Future<BR><FONT COLOR="#000000"><I><SPAN STYLE="text-decoration: none"><A CLASS="western" HREF="http://ipsi.fraunhofer.de/ambiente/">http://ipsi.fraunhofer.de/ambiente/</A></SPAN></I></FONT><I>
</I></FONT>
</P>
<H1 CLASS="heading-1*-western">Abstract</H1>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The devices
available in ubiquitous computing environments offer new
possibilities for interaction. In the context of meetings and
teamwork situations, it is desirable to take advantage of their
properties for synchronous collaboration. Besides offering an adapted
user interface, this requires that the software infrastructure is
designed for <I>synchronous access</I> to shared information objects
using <I>heterogeneous devices</I> with <I>different interaction</I>
characteristics. As this field is still emerging and no mature
standards are at hand, it is necessary to provide guidance for
UbiComp developers how to model their applications to ensure both
extensibility for future developments and reusability in new
contexts.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In this paper, a
conceptual model for synchronous applications in ubiquitous computing
environments is proposed. To test its applicability, it was used to
structure the architecture of the BEACH software framework that is
the basis for the software infrastructure of <SPAN LANG="">i-LAND</SPAN>
(the ubiquitous computing environment at FhG-IPSI). The BEACH
framework provides the functionality for synchronous cooperation and
interaction with roomware components, i.e. room elements with
integrated information technology. To show how the BEACH model and
framework can be applied, the design of a sample application is
explained. Also, the BEACH model is positioned against related work.
In conclusion, we provide our experiences with the current
implementation.</P>
<H2 CLASS="heading-2*-western">Keywords</H2>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Synchronous
collaboration, heterogeneous devices, software architecture,
conceptual model, BEACH application model and framework, <SPAN LANG="">i-LAND</SPAN>,
roomware components</P>
<H1 CLASS="western">1Introduction</H1>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Ubiquitous computing
environments offer a wide range of devices coming in many different
sizes and shapes [[UbiComp-Issues]]. Being often occupied by multiple
users simultaneously, ubiquitous computing environments must support
synchronous work with information that is shared among all present
devices. Due to the heterogeneous nature of ubiquitous computing
devices, their software infrastructure must enable user interfaces
taking advantage of their different properties. In addition, it must
enable tight collaboration of users working with different devices or
sharing the same device.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Current operation
systems provide no support for handling this heterogeneity.
Synchronous collaboration can be handled by several
computer-supported cooperative work frameworks, groupware systems, or
middleware infrastructures, but these systems have no support for
heterogeneous devices. There are research prototypes aimed at
managing devices with different interaction capabilities, but these
projects mainly deal with interfaces for and discovery of simple
services and lack support for tight collaboration. There is a need
for a software infrastructure designed for handling heterogeneous
environments, providing adequate interaction styles and user
interface concepts, as well as offering capabilities for synchronous
collaboration. As this kind of infrastructure is built on top of
current operating systems, which handle the interaction with the
specific hardware, it can be referred to as &ldquo;meta-operating
system&rdquo; [[Gaia-GaiaOS]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Over the last five
years, we have been working at IPSI, the Fraunhofer Integrated
Publication and Information Systems Institute in Darmstadt (Germany),
in the context of the <SPAN LANG="">i-LAND</SPAN> project on support
for synchronous collaboration with roomware components
[[Roomware-Matters], [Roomware-i-LAND], [Roomware-NextGeneration],
[Roomware-SecondGeneration]]. &ldquo;Roomware&rdquo; is a term we
coined to refer to room elements with integrated information
technology such as interactive tables, walls, or chairs.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The work presented
here was originally triggered by the need to create a software
infrastructure for this roomware environment. This led to the
development of a software prototype called &ldquo;BEACH&rdquo;, the
<U>B</U>asic <U>E</U>nvironment for <U>A</U>ctive <U>C</U>ollaboration
with <U>H</U>ypermedia. BEACH provides the software infrastructure
for environments supporting synchronous collaboration with many
different devices. It offers a user interface that also fits to the
needs of devices that have no mouse or keyboard, and which require
new forms of human-computer and team-computer interaction. To allow
synchronous collaboration BEACH builds on shared documents accessible
via multiple interaction devices concurrently.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">During the
development, BEACH was restructured and refactored
[[Refactory-Smalltalk], [Jacobsen-SoftwareModelling]] several times.
It became obvious that a <I>conceptual model</I> was needed to guide
developers of ubiquitous computing applications. This led us to the
work presented here. Parts of BEACH emerged into a software framework
with an architecture that is structured according to the conceptual
model for synchronous ubiquitous computing applications proposed in
this paper. The model aims at offering both flexibility and
extensibility for different devices that are part of ubiquitous
computing environments.</P>
<H2 CLASS="western"><A NAME="sContributingAreas"></A>1.1Involved
Research Areas</H2>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Due to the nature of
collaborative ubiquitous computing environments, the results of
several related research areas have to be combined to gain an
integrated application model that covers all aspects of interaction
and collaboration (fig. 1-1.1):<SUP><A CLASS="sdfootnoteanc" NAME="sdfootnote1anc" HREF="#sdfootnote1sym"><SUP>1</SUP></A></SUP></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT FACE="Times, serif">Human-Computer
	Interaction (HCI) deals with user interfaces and interaction
	techniques.</FONT></P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT FACE="Times, serif">Ubiquitous
	computing (UbiComp) explores dynamic environments with heterogeneous
	devices.</FONT></P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT FACE="Times, serif">Computer-Supported
	Cooperative Work (CSCW) offers techniques to handle synchronous
	interaction with distributed computers.</FONT></P>
	<LI><P><FONT FACE="Times, serif">Software development techniques are
	needed to ensure extensibility and reusability.</FONT></P>
</UL>
<P LANG="de-DE" ALIGN=CENTER STYLE="margin-top: 0.39cm; margin-bottom: 0.39cm; widows: 0; orphans: 0; page-break-after: avoid">
<IMG SRC="sample_html_49014637.gif" NAME="Graphic1" ALIGN=BOTTOM WIDTH=342 HEIGHT=172 BORDER=0></P>
<P STYLE="margin-left: 0.49cm; margin-right: 0.66cm; margin-bottom: 0.35cm"><A NAME="fContributingAreas"></A>
<FONT FACE="Helvetica, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Figure
<SPAN LANG="">1</SPAN>&nbsp;1.1.<SPAN LANG=""> Conttibuting research
areas for the design of collaborative ubiquitous computing
applications.</SPAN></FONT></FONT></P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">A successful model
for collaborative ubiquitous computing applications must combine the
results of all involved research areas.</P>
<H2 CLASS="western">1.2Outline of the Paper</H2>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In the following
section, requirements for the software infrastructure of a ubiquitous
computing environment to support synchronous collaboration are
discussed. A sample application, the Passage system, is introduced,
which is used in the following to illustrate the application of the
BEACH model and framework. Based on the identified requirements, the
proposed conceptual application model has been designed, which is
presented next. The succeeding section presents the architecture of
the BEACH software framework, which has been developed according to
the structure suggested by the conceptual model. The software design
of the Passage system is explained as a sample application of the
BEACH model and framework. To position the BEACH model against other
approaches, the next section compares the proposed model with related
work. The paper closes with a discussion of the conceptual model and
ideas for future work.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">[# &hellip;. Bla bla
bla &hellip; some stuff removed &hellip; #]</P>
<H1 CLASS="western"><A NAME="cConceptualModel"></A>2A Conceptual
Model for Ubiquitous Computing Applications</H1>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">A conceptual model
defines the very high-level structure of an application
[[Groupware-Architectures], [PAC-UI-Architecture]]. By using this
structure for applications, basic components are identified that have
a clear separation of concerns, thus supporting their independence
and increasing their flexibility and adaptability. According to the
definition by [ :inline | [Nowack-Structures+Interactions]] a
&ldquo;conceptual model describes a conceptual understanding of
something, and it is based on concept formation in terms of
classification, generalization and aggregation. Hence, conceptual
modeling implies abstraction&rdquo;. Abstraction is a key technique
to overcome software complexity by allowing the developer to focus on
one specific aspect at a time. By using this structure for
applications, basic components are identified that have a clear
separation of concerns, thus supporting their independence and
increasing their flexibility and adaptability
[[BuildAppFWs-Viewpoints]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In this section, a
conceptual model for ubiquitous computing applications is presented.
Organized by three major design dimensions, which are identified
first, its properties are discussed.</P>
<H2 CLASS="western">2.1Design Dimensions</H2>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In order to identify
the design dimensions for a conceptual model, results of all
contributing research areas (identified in section 1.1) have to be
considered. Looking at these four areas, contributions for a
conceptual model can be identified (fig. 4-2.1):</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT FACE="Times, serif">Human-Computer
	Interaction (HCI) is concerned with <I>user interface &amp;
	interaction</I>.</FONT></P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT FACE="Times, serif">CSCW has
	identified different degrees of <I>coupling</I> and different
	mechanisms for <I>sharing</I>.</FONT></P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT FACE="Times, serif">Ubiquitous
	computing (UbiComp) has to deal with <I>device</I> heterogeneity and
	their relation to the <I>environment</I> in which they are used.</FONT></P>
	<LI><P><FONT FACE="Times, serif">And, finally, <I>separating
	specific concerns</I> and defining <I>levels of abstraction</I> are
	very important software modeling techniques.</FONT></P>
</UL>
<P LANG="de-DE" ALIGN=CENTER STYLE="margin-top: 0.39cm; margin-bottom: 0.39cm; widows: 0; orphans: 0; page-break-after: avoid">
<IMG SRC="sample_html_m1d98ba7c.gif" NAME="Graphic2" ALIGN=BOTTOM WIDTH=308 HEIGHT=238 BORDER=0></P>
<P STYLE="margin-left: 0.49cm; margin-right: 0.66cm; margin-bottom: 0.35cm"><A NAME="fContributionsForRWApp"></A>
<FONT FACE="Helvetica, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Figure
<SPAN LANG="">4</SPAN>&nbsp;2.1. Contributions to roomware
applications by the different research areas. Figure 1-1.1 is
extended to show the contributions of every involved research area.</FONT></FONT></P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">These contributions
can be arranged as three design dimensions: <I>separation of
concerns</I>, <I>coupling and sharing</I>, and <I>level of
abstraction</I>. While the contributions &ldquo;degree of coupling&rdquo;
and &ldquo;level of abstraction&rdquo; define a dimension on their
own, &ldquo;user interface &amp; interaction&rdquo; and &ldquo;devices
&amp; environment&rdquo; represent different concerns of UbiComp
software systems that should be separated to simplify building
abstractions and models [[Jacobsen-SoftwareModelling],
[BuildAppFWs-Viewpoints]]. Hence, they can be combined to a single
dimension. Separation of concerns and levels of abstraction are two
independent properties of a system structure
[[Parnas-DecomposingSystems]]. This allows seeing them as independent
dimensions.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">These three design
dimensions &ndash; <I>separation of concerns</I>, <I>coupling and
sharing</I>, and <I>level of abstraction</I> &ndash; constitute the
basic dimensions of the conceptual model proposed in this paper. Each
of these dimensions will be discussed in the following.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The model presented
here is an updated version of the model published in
[[BEACH-SyncCollaboration]], adding the third dimension for <I>coupling
and sharing</I>. In addition, a graphical notation to visualize the
model in design diagrams is proposed.</P>
<H2 CLASS="western"><A NAME="sBasicModels"></A>2.2First Dimension:
Separating Basic Concerns</H2>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">As described above,
it is necessary for different devices to have different user
interface elements (req. ). Also, different tools are useful
depending on the device(s) at hand (req. ). In order to achieve the
flexibility needed for different devices, it is important to clearly
<I>separate different responsibilities</I> within the software.
Therefore, models for the data, application, user interface,
interaction, and environment are distinguished (fig. 4-2.2). The term
&ldquo;model&rdquo; here refers to a part of an application handling
a specific concern [[Jacobsen-SoftwareModelling]].</P>
<P LANG="de-DE" ALIGN=CENTER STYLE="margin-top: 0.39cm; margin-bottom: 0.39cm; widows: 0; orphans: 0; page-break-after: avoid">
<IMG SRC="sample_html_72d23e29.gif" NAME="Graphic3" ALIGN=BOTTOM WIDTH=366 HEIGHT=182 BORDER=0></P>
<P STYLE="margin-left: 0.49cm; margin-right: 0.66cm; margin-bottom: 0.35cm"><A NAME="fBasicModels"></A>
<FONT FACE="Helvetica, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Figure
<SPAN LANG="">4</SPAN>&nbsp;2.2. Dependencies between data,
application, user-interface, environment, and interaction model</FONT></FONT></P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The <I>data model</I>
specifies the kind of data the users can create and interact with. To
work with data, a <I>application</I> provides the necessary
functionality. These two models are independent of the currently used
or supported hardware device. Instead, available devices and other
relevant parts of the environment are described by the <I>environment
model</I>. The <I>user-interface model</I> defines the framework for
how the applications can be presented to the user, taking into
account the properties of the environment model. These models are not
applicable for ubiquitous computing applications only. Yet, due to
the heterogeneous environment in which they operate, they have a
strong need for a clear structure that gives the flexibility to adapt
different components independently for different situations.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In the following,
these five models are presented in more detail, including their
relationship to the previously identified requirements. Concrete
examples of how these models have been applied are given afterwards.</P>
<H3 CLASS="western"><A NAME="_Ref517456041"></A><A NAME="sDataModelConcept"></A>
Data Model: Information Objects</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">It is a very common
approach in application modeling to separate the application model
from the data or domain model [[VisualWorks-UsersGuide],
[HUMANOID-Model]]. The data model relates to the <I>information
dimension</I> identified by [ :inline | [Jacobson-OOSE]], while the
application model represents the <I>behavior dimension</I>. This way,
both data and application models can be reused independently.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Different
applications can be specified and implemented for one kind of data.
This can save much time if the current application domain has complex
data structures or algorithms. On the other hand, application models
can be reused for different kinds of data, if the interface between
the application and the data has been defined very carefully at an
appropriate level of abstraction.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The data model
defines the classes and functionality of all objects that can be part
of a document. According to an object-oriented view, data objects
combine document state with methods to change the state. In the
context of cooperative work (req. ), it makes sense to choose a
fine-grained model to gain more flexibility in defining different
aspects of collaboration, like the degree of coupling (req. ). In
[[Dragonfly-Architecture]] the model facet represents the data model.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Following an
object-oriented approach, the data model will usually consist of a
network of multiple connected objects. For hypertext-like documents,
e.g., it is popular to define one main containment hierarchy with
additional connections defined by hyperlinks.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Depending on the
actual application, data objects are not restricted to represent what
is classically seen as a &ldquo;document&rdquo;. In
[[PlacelessDoc-Generality+Specificity]] a much broader view on
documents is described. If, for instance, physical devices, people,
or tasks are also treated as special kinds of &ldquo;documents&rdquo;,
a uniform interface can be used. The term &ldquo;domain model&rdquo;,
which is sometimes also used for the concept of a data model
[[VisualWorks-UsersGuide], [COAST-Model]], stresses that it models
the artifacts of a given domain, which may not be necessarily
documents. Although this term can be used interchangeably with &ldquo;data
model&rdquo;, this paper uses the latter term in order to provide a
clearer contrast with the application model.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Looking at the
example of the Passage system, the data model covers all objects that
should be attached to and carried with a passenger object. The
implementation described below (see section ) supports the generic
document elements provided by the BEACH framework, but also new
document elements defined by other BEACH modules.</P>
<H3 CLASS="western"><A NAME="sApplicationModelConcept"></A>Application
Model: Application Behavior</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Application models
are used to describe all application aspects such as manipulation of
data objects. As application models define the <I>behavior</I> of the
application, they specify control objects as defined in
[[Jacobson-OOSE]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">For a &ldquo;text&rdquo;
object, the data model includes the string describing the text and
text attributes like font or size. The application model adds the
editing state for text, for instance, cursor position or selection.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Further, it can
specify the degree of coupling between different users, i.e. it
controls which parts of the editing state are shared by which users,
and where private values are allowed. The workspace application
model, e.g., allows specifying different rotations of the workspace
for two users working at an interactive table (see req. ), while all
other properties are tightly coupled.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">To be able to use
different application models for the same data model, the data model
has to be unaware of any application model and represent document
state only.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">It has proven
helpful to choose a rather fine granularity for some application
models. This way, low-level application models with a well-defined
functionality (e.g. to edit a simple text) can be aggregated to form
more complex models at a higher level of abstraction (e.g. an editor
that can manage complete workspaces). Usually, a whole hierarchy of
application models composed of generic, reusable parts and custom
parts constitute an application [[COAST-Model]]. This way, the
application model often forms a hierarchy that is isomorphic to the
containment hierarchy of its associated data model
[[VisualWorks-UsersGuide]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Using small
application models turns out to foster a new conception of what is
regarded as an application. The application model is seen as a
description of <I>additional</I> semantics for a data model, instead
of the conventional approach of seeing data as a &ldquo;supplement&rdquo;
to be edited by applications. It therefore leads to an
<I>information-centric</I> perspective on application models
[[iRoom-VisualInstruments]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The Passage system,
e.g., defines no new application model. Instead, it reuses the
application models that are available for the data objects being
attached to passengers. In fact, it associates the application model
with a passenger object (in contrast to creating an association
between passenger and data object) as shown in figure  below. This
way, the current editing state (e.g. selections, cursor position
etc.) can be transferred using Passage; this allows users to go to
another roomware component and continue working there at exactly the
same state.</P>
<H3 CLASS="western"><A NAME="sUIModelConcept"></A>User-Interface
Model: Interface Elements</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">As traditional
operating and window management systems have been designed for use
with a traditional desktop PC, the interface they offer has drawbacks
when used with devices not having a mouse and keyboard or having
different forms and sizes. For instance, if a menu bar is always at
the top of the screen, it might be hard to reach at a wall-size
display [[Pier-LocationIndepInterfaces]]. Toolbars can take up a lot
of precious screen space on a PDA-like device.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Therefore, the user
interface aspects have to be separated from information and behavior
of applications. This is related to the <I>interface dimension</I>
identified by [ :inline | [Jacobson-OOSE]]. However, the BEACH
conceptual model further distinguishes the <I>user interface</I> from
the <I>interaction</I>, to allow accessing a shared user interface
with different modalities and different devices. The user interface
model defines the components that are available in the user
interface, while the interaction model specifies how they are
presented and modified.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In the case of the
Passage system, the user interface is rather simple; it consists of
the virtual part of the bridge. The <I>virtual</I> part of the bridge
is displayed on a roomware component whenever a passenger is detected
on the <I>physical</I> part of the bridge (see figure ).</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The user-interface
model allows one to define alternative user-interface concepts
suitable for different interaction devices (req. ). Multiple-computer
devices (req. ) and multi-device interaction (req. ) make it
necessary to have user interface elements that can be distributed and
shared among different devices (see below).</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">By explicitly
modeling an appropriate user-interface, all issues related to the
hardware and physical environment can be addressed at one point,
allowing applications and documents to be device-independent.</P>
<H3 CLASS="western"><A NAME="sPhysicalModelConcept"></A>Environment
Model: Context Awareness</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">One major property
of ubiquitous computing environments is the heterogeneity of the
available devices. In order to provide a coherent user experience
[[DisappearingUI-CoherenceScope]], the &ldquo;system must have a
deeper understanding of the physical space&rdquo;
[[EasyLiving-Technologies]]. This raises the need for an adequate
model of the application&rsquo;s physical environment.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Therefore, the
environment model is the representation of <I>relevant</I> parts of
the &ldquo;real&rdquo; world. On one hand, this includes a
description of which devices are used, how they are configured, and
which capabilities they have. This is the direct <I>hardware
environment</I>, which can be employed by the user-interface model to
adapt to different devices (req. ). This part corresponds to the
platform model defined by the Plasticity framework
[[Plasticity-Framework+Agenda]], or Aura&rsquo;s notion of
environment [[Aura-Framework]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In addition, other
aspects can be included if they can influence the behavior of the
software. Necessarily, it has to be possible to measure their
relevant properties with sensors. Depending on detected changes in
the <I>physical environment</I>, further actions can be triggered to
reflect the current situation (req. ).</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The Passage system
is an example of how to react upon changes in the physical
environment. As mentioned, the virtual part of the bridge is shown as
soon as a physical object is detected on the physical part of the
bridge. Thus, Passage needs to keep a representation of the detected
physical objects and the location (esp. bridge) where they have been
sensed (fig. ). This is part of the environment model. Additionally,
the sensors used for detecting physical objects belong to the
environment model as well.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Besides the physical
environment, other contextual information &ndash; such as the current
task, project, or presence of co-workers &ndash; could influence the
behavior of the software, so long as this information is available to
the application. This part refers to the <I>logical context</I> of
the application.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Software with
functionality depending on physical objects and their properties, or
other aspects of the user&rsquo;s environment (req. ) is called
<I>context-aware </I>[[ContextToolkit-AppDevelopment]]. There is a
strong need for context-aware applications in ubiquitous computing
environments, as the large number of available devices, services, and
tools can be a burden for the user if the complexity for explicit
interaction becomes too high. An environment designed to support the
users needs, needs to aim at <I>implicit</I> interaction
[[Schmidt-ImplicitHCI]]. This can be accomplished by using changes in
the real world&rsquo;s state to trigger software functionality.<SUP><A CLASS="sdfootnoteanc" NAME="sdfootnote2anc" HREF="#sdfootnote2sym"><SUP>2</SUP></A></SUP>
Therefore, the environment model must be capable of expressing
relevant information, such as spatial relationships between physical
objects.</P>
<H3 CLASS="western"><A NAME="sInteractionModelConcept"></A>Interaction
Model: Presentation and Interaction</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">To be able to
support different styles of interaction (req. , ), the interaction
model specifies how different interaction styles can be defined. The
term used here describes a part of the software architecture, and
should not be confused with the &ldquo;interaction model&rdquo;
describing the &ldquo;look and feel&rdquo; of a user interface at a
conceptual level as defined by [ :inline |
[BeaudouinLafon-PostWIMPModel]]. Instead, it is a generalized view of
the &ldquo;interaction model&rdquo; described by [ :inline |
[Suite-CouplingUIs]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">As shown in figure
4-2.2, the interaction model defines a way to interact with all other
basic models. This is necessary, as all models can define aspects and
functions that can be represented for and accessed by the user. For
example, a data object like a &ldquo;text&rdquo; object often has a
directly attached view and controller, enabling direct interaction
with the text; then, interaction and data model communicate directly,
bypassing user interface and application models. Alternatively, a
&ldquo;visual interaction area&rdquo; being part of the user
interface model, provides functionality that has an immediate visual
representation rendered by the interaction model. In other cases, the
interaction model will not access the data model directly. Instead,
it is associated with an appropriate application model as a mediator
to the data model. This way, the interaction style can be adapted
depending on which application model is used to access a data model.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">As an appropriate
interaction style depends on the available interaction devices and
the associated user interface, a suitable interaction model can be
chosen depending on the environment and user-interface model. For
visual-based interaction, an adapted version of the
model-view-controller concept [[MVC-Cookbook],
[COAST-ooSyncGroupware]] has proven successful. However, the &ldquo;model&rdquo;
of the model-view-controller concept is not further structured. It
can refer to each of data, application, user interface, or
environment model.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Passage defines an
interactive visual representation (for the virtual part of the
bridge) and physical actions as input (placing objects on the
physical part of the bridge). Consequently, its interaction model
uses both a visual interaction model (see section ) and a sensor
model providing the basis for detecting physical objects (see section
).</P>
<H2 CLASS="western"><A NAME="sConceptualSharing"></A>2.3Second
Dimension: Coupling and Sharing</H2>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Whenever multiple
devices are involved in a software system, the question arises, which
parts of the system should be local to a device or shared between
several. This has to be clarified for both the application code and
its state. While <I>distributing code</I> among devices is a
technical question unique to every application, <I>sharing state</I>
has conceptual implications, which this section addresses.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Today, many
applications still run entirely local to a single computer, or access
only data that is distributed over a network. Aiming at synchronous
collaboration, crucial aspects of traditional CSCW systems are <I>access
to shared data</I> and <I>coupling the applications </I>of
collaborating users [[Suite-CouplingUIs]]. Therefore, coupling has to
be applied to both the data and the application model
[[COAST-Model]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In the context of
ubiquitous computing environments, this view has to be extended. In
addition to data and application, also information about the physical
environment, e.g., the presence of nearby users or other available
interaction devices, has to be exchanged by different devices and
applications.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">As discussed above,
in a ubiquitous computing environment elements of the user interface
can be distributed among several machines (req. ) or among different
devices (req. ). Based on the separation of concerns that has been
previously identified, Dewan&rsquo;s definition of coupling
[[Dewan-FlexibleUICoupling]] can be refined. Coupling can now be
defined as <I>sharing the same interaction, user interface, or
editing (application) state</I> among several users or devices.
Coupling can thus simply be implemented as accessing the same user
interface or application model. This is an important benefit of using
shared user interface and application models.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Depending on how
much state is shared, the <I>degree of coupling</I> can be
controlled. If all involved user interface and editing state is
shared, a tightly coupled collaboration mode is realized; if only the
same data model is shared, users work loosely coupled (req. ). This
is related to the coupling model described in [[Suite-CouplingUIs]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Even, if some models
are not coupled, one can profit from sharing environment, user
interface, and application models. As the information encapsulated in
the models is accessible to all clients, it is possible to provide
<I>awareness information</I> in the user interface. Typical for CSCW
applications is the provision of workspace or activity awareness
[[GroupKit-AwarenessWidgets], [Interlocus-ActivityAwareness]]. This
can easily be realized if the application model including all editing
state is shared [[COAST-Model]]. While tightly coupling the user
interface can be inconvenient [[GroupKit-AwarenessTradeoffs],
[Colab-WYSIWIS-Rev]], shared user interface information provides a
means of giving additional awareness hints to remote users.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Beyond the provision
of awareness in CSCW systems, sharing the environment model allows a
new kind of awareness for ubiquitous computing environments. The
information embodied in the environment model can be used to give
environmental awareness.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">This section
discusses the aspects of sharing the basic models. Before starting a
detailed discussion, it has to be noted that &ldquo;sharing&rdquo;
can be implemented in many different ways. In the case of
collaborating devices with quite varying properties &ndash;
especially in terms of memory, performance, or network connection &ndash;
a shared object does not necessarily have to have the same
implementation for different platforms (see e.g. Manifold
[[Manifold-Architecture]] or Pocket Dream Team
[[QuickStep-Challenges]]). For example, a shared &ldquo;image&rdquo;
object is likely to have a different implementation on a high-end
desktop PC than on a PDA. At the conceptual level, however, both
implementations refer to the same shared object.</P>
<H3 CLASS="western">Sharing the Data Model: Collaborative Data Access</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In order to access
and work collaboratively with shared data (req. ), it is widely
agreed that a shared model for documents reduces the complexity in
dealing with distributed applications. While there are
well-established models defining a shared data model providing
read-only access only (e.g. the world-wide-web), it is much more
complicated to allow simultaneous modifications at a fine
granularity.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Most popular
toolkits and frameworks for computer-supported cooperative work
provide some mechanism to manage a shared-object space. In toolkits
with a centralized architecture [[Rendezvous-Demands]], the document
is necessarily shared. Replicated (or semi-replicated
[[Groupware-Architectures]]) systems create a shared-object space by
synchronizing the replicated objects [[Clock-Architecture],
[Dragonfly-Architecture], [COAST-ooSyncGroupware]]. In later versions
of GroupKit [[GroupKit-CSCW92], [GroupKit-RealTime]] shared
&ldquo;environments&rdquo; have been introduced as shared data
structures that can trigger callbacks upon changes.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Application
designers thus have to decide to which degree or for which parts of
their application shared access to data is desirable or necessary.
For the Passage system, a shared data model enables a straightforward
access to data objects from different computers, which is necessary
when a passenger is transferred to another roomware component.</P>
<H3 CLASS="western"><A NAME="sApplicationModelSharing"></A>Sharing
the Application Model: Workspace Awareness &amp; Degree of Coupling</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">To have an easy way
of getting information about the editing state of other users, it has
been proposed not only to share the data model, but also to share the
application model [[COAST-Model]]. Sharing the editing state gives
the ability to provide awareness about editing activities. Taking
again the example of a text-edit application model, sharing it opens
the opportunity to visualize, e.g., text cursors or selections of
remote users.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">By changing the
state of the application model, the degree of coupling or other
possible work modes can be controlled (req. ). Users working with the
same application model can work tightly coupled with rich awareness
information [[COAST-Model]]. Tightly coupled work could for instance
include a coupled scroll position, coupled selection, or coupled
navigation. If separate instances of the application model or
different application models are used, users can still work loosely
coupled when they modify the same data.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Again, the
application designer has to decide whether or not a tightly coupled
work mode should be supported or how much awareness information is
advantageous. As already mentioned, the Passage system allows
transporting both data and current editing state. This is enabled by
a shared application model.</P>
<H3 CLASS="western">Sharing the User Interface Model: Distributed &amp;
Coupled User Interfaces</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">If one user
interacts with different devices at the same time (req. ), it is
desirable that their user interfaces are coordinated. This is only
possible, if the information about the currently used user interface
elements is accessible to all involved devices. An example of how
user interfaces can be coupled is the &ldquo;join&rdquo; operation of
&ldquo;join and capture&rdquo; [[XWeb-JoinCapture]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In addition, some
devices actually have several embedded computers (req. ). When a
visual interaction area crosses the borders between displays that are
physically placed next to each other, but connected to different
machines, it is necessary that the user interface elements be freely
movable between the different displays  [[BEACH-ConnecTables]]. In
this case, user interface elements must be shared between the
involved machines.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">However, for the
Passage system, a shared user interface model is not necessary. It is
sufficient that the virtual part of the bridge runs as an application
local to each computer equipped with a bridge. Nevertheless, if the
user interface is shared, it is possible to control the bridge
remotely, opening opportunities for extensions. Then, sensors
attached to different computers can be used to detect objects on the
bridge. If, for instance, video recognition is used to identify
passenger objects, it is quite likely that the video camera is
attached to a different computer. This computer can provide the
performance for processing the video signal &ndash; without affecting
with the performance of the roomware component. Another extension we
implemented uses Palm Pilot PDAs to &ldquo;beam&rdquo; data to the
bridge of a roomware component [[BEACH-CreativityTools]]. Here,
again, the shared user interface can be controlled remotely by the
Palm.</P>
<H3 CLASS="western">Sharing the Environment Model: Environmental
Awareness</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">When several people
and devices physically share a common environment, it is obvious that
applications that are used in such situations can benefit from a
shared model of how their environment looks.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In ubiquitous
computing environments, many different devices have attached sensors
that allow detection of some aspects of the physical environment. By
combining all available information and making it accessible to other
applications, it is possible for each application to draw on a lot of
context information that can be used to adapt its behavior (req. ).
Similar to the workspace awareness (which is enabled by a shared
application model), a shared environment model can serve as the basis
for environmental or context awareness. This is especially important
in figuring out which users and interaction devices are currently
present and available.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">For a system such as
Passage, a shared environment model &ndash; similar to a shared user
interface model &ndash; offers possibilities for extensions. In fact,
for the example extensions used to illustrate the benefits of a
shared user interface model, a shared environment model could be used
instead. In this case, the environment model is modified remotely,
instead of the user interface model. Then, sensors distributed in the
environment update the shared representation of the existing
passenger objects and their detected locations.</P>
<H3 CLASS="western">Sharing the Interaction Model: Disaggregated
Computing</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Advantages of
implementing data, application, user interface, and environment model
as shared objects to give several users or devices the possibility to
access these objects simultaneously have been discussed. In contrast,
some interaction model objects always have to be local to each
machine. This is necessary, as interaction model objects communicate
with the interaction devices that are attached to the local computer.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In a ubiquitous
computing environment however, the computer, to which an interaction
device is attached, should become irrelevant, leading to what is
called &ldquo;disaggregated computing&rdquo; [[EasyLiving-UbiComp]].
Systems such as PointRight [[iRoom-PointRight]] or Mouse Anywhere of
EasyLiving [[EasyLiving-Technologies]] route input events to remote
computers and introduce proxy device drivers. These are examples, how
an interaction model can be partially shared. It is partially shared,
as the device drivers still remain local to a machine.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Another benefit of a
local interaction model is the ability to adapt the interaction style
according to each client&rsquo;s local context, especially its
physical environment and interaction capabilities. An extensive
example of how local interaction objects can be used to adapt to
their local context is given in [[BEACH-ConnecTables]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">For the Passage
system, though, a local interaction model is sufficient. The visual
representation of the virtual part of the bridge has to be rendered
locally at the computer, to which the roomware component&rsquo;s
display is attached. This is normally the same computer receiving
also the mouse or pen events for that display. Accordingly, the
observer process, watching for detected physical objects, should
normally run on the same machine where the bridge is located. As it
modifies the state of the user interface model upon detected physical
objects, the observer process itself needs no own state.
Consequently, it has no state that could be shared.</P>
<H2 CLASS="western"><A NAME="sConceptualLevels"></A>2.4Third
Dimension: Conceptual Levels of Abstraction</H2>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The third dimension
of the conceptual model is the <I>level of abstraction</I>. It is a
widely used software engineering technique to separate different
levels of abstraction in order to reduce the complexity on each level
[[Dijkstra-THE-structure], [PAC-AMODEUS], [Zypher-Tailorability]] and
to ensure interoperability [[HCI.Context-Infrastructure]].</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">While the
C2-architecture places different functionality at different levels
[[Chiron-2-Architecture]], we rather see the level of abstraction
being orthogonal to functionality. As different functionality should
be separated by different basic models, software components
implementing one model can belong to different levels. For example,
core functionality of the <I>interaction model</I>, such as the
handling of physical interaction devices, belongs to a very low
level. Based on this functionality, abstractions are defined, e.g.
widgets or logical device handlers. High-level interaction components
use these abstractions to define the user&rsquo;s access and
interaction possibilities for some other model being at the same
level of abstraction.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In practice, the
number of levels actually used may vary. In the context of framework
development, it has been recommended to define three layers as part
of the functional view on the architecture
[[BuildAppFWs-FWs+DomainModels]], the environment layer, the
domain-specific layer, and the application-specific layer. These
represent three different <I>conceptual levels of abstraction</I>.
Handling environment and platform issues belongs to the <I>core</I>
level, domain-specific functionality represents the <I>generic</I>
level, and application-specific functionality is located at the <I>task</I>
level. Similar levels are defined in [[AMF-FW+PatternSyncGW]] in the
context of CSCW systems.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Still, besides the
three commonly acknowledged levels, one additional level, the <I>model</I>
level, is needed to represent common abstractions for all basic
concerns (fig. 4-2.3) in an application-, domain-, and
platform-independent way. Please note that the term <I>level</I> is
used in contrast to <I>layer</I> to denote a conceptual level of
abstraction. A layer is a software technique to structure software
architecture and can be used to reflect different levels of
abstraction in architecture and implementation.</P>
<P LANG="de-DE" ALIGN=CENTER STYLE="margin-top: 0.39cm; margin-bottom: 0.39cm; widows: 0; orphans: 0; page-break-after: avoid">
<IMG SRC="sample_html_m8a536e8.gif" NAME="Graphic4" ALIGN=BOTTOM WIDTH=283 HEIGHT=140 BORDER=0></P>
<P STYLE="margin-left: 0.49cm; margin-right: 0.66cm; margin-bottom: 0.35cm"><A NAME="fConceptualLevels"></A>
<FONT FACE="Helvetica, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Figure
<SPAN LANG="">4</SPAN>&nbsp;2.3.<SPAN LANG=""> Four conceptual levels
of abstraction: core, model, generic, and task level</SPAN></FONT></FONT></P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The remainder of
this section discusses these levels, starting at the bottom with the
core layer.</P>
<H3 CLASS="western">Core Level: Specialized Infrastructure</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The core level
provides functionality that will make the development of the higher
levels more convenient and portable by encapsulating
platform-dependent details. Functionality normally provided by the
(meta-) operating system, middleware infrastructures, or groupware
and user interface toolkits resides at this level.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">For roomware
applications, additional functionality may be necessary, which is not
available from off-the-shelf libraries or toolkits. This can include
support for multi-user event handling, or low-level device and sensor
management. For instance, this includes drivers for the sensors used
to detect physical objects by the Passage system.</P>
<H3 CLASS="western">Model Level: Abstractions to Ensure
Platform-Independent Separation of Concerns</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The aim of the model
level is to provide application-, domain-, and platform-independent
abstractions to be used as the basis for the definition of
higher-level abstractions. These abstractions can be implemented on
top of the core level. This implies that the implementation of the
model level maps the platform-dependent abstractions defined at the
core level to the platform-independent abstractions constituting the
interface of components at the model level.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Components at the
model level typically define abstract classes that allow different
implementations for different platforms, e.g., using the Abstract
Factory or Bridge pattern as defined in [[GoF-DesignPatterns]]. For
the platform-independent implementation of user interface and
interaction models for instance, it is quite common to use an
abstract GUI framework, such as Java AWT/Swing, or the VisualWorks
GUI framework [[VisualWorks-UsersGuide]]. These frameworks provide
good examples for components at the model level.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The Passage system
uses the abstract definition of sensors and application models
provided by the BEACH framework. This way, arbitrary sensors can be
used to detect objects and arbitrary application models can be
attached to passengers. To implement the interaction, two models of
interaction styles are used. The view model (see section ) provides
the base to render the virtual part of the bridge; the sensor model
(see section ) is used to detect objects placed on the physical part
of the bridge (see fig. ).</P>
<H3 CLASS="western">Generic Level: Reusable Functionality</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">One important goal
of every software system is to provide generic components that are
useful in many different situations and for different tasks (req. ).
Each application domain has common concepts and algorithms that can
be applied by a number of software systems.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">Generic and
domain-specific models and concepts should therefore be grouped at a
generic level. This way, the designer is forced to think about
generic concepts, which will lead to the implementation of reusable
elements.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">For example, the
Passage system uses the generic document elements defined by the
BEACH framework to be associated with passenger objects, instead of
defining document elements on its own.</P>
<H3 CLASS="western">Task Level: Tailored Support for Specific Tasks</H3>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">When generic
elements only are defined, this obviously restricts the usability of
the application to some limit. For some tasks, it is of help if
specific support is given (req. ). Therefore, the conceptual model
needs a task level, which groups all high-level abstractions that are
unique a single application only. However, in order to increase the
amount of reusable components, the application designer should aim at
minimizing application-specific code. Ideally, an application needs
to do no more than glue together existing software components.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The overall Passage
system is located at the task level, as it supports the task
&ldquo;transportation of information (including its current editing
state) between roomware components&rdquo;. It relies on generic
models, only defining the high-level user interface and specifying
the supported interactions.</P>
<H2 CLASS="western">2.5The BEACH Conceptual Application Model</H2>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">With the three
dimensions that have been discussed in detail, the overall conceptual
model can be visualized as shown in figure 4-2.4. Looking at the
dimension of the level of abstraction and the dimension of the
separation of concerns, these two dimensions open a grid, which can
be used to place all software components or assign software
functionality. In contrast, the degree of coupling specifies the
level of collaboration for this functionality rather that defining or
categorizing functionality itself.</P>
<P LANG="de-DE" ALIGN=CENTER STYLE="margin-top: 0.39cm; margin-bottom: 0.39cm; widows: 0; orphans: 0; page-break-after: avoid">
<IMG SRC="sample_html_m512dd214.gif" NAME="Graphic5" ALIGN=BOTTOM WIDTH=346 HEIGHT=186 BORDER=0></P>
<P STYLE="margin-left: 0.49cm; margin-right: 0.66cm; margin-bottom: 0.35cm"><A NAME="fDesignDimensionsRWApp"></A>
<FONT FACE="Helvetica, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Figure
<SPAN LANG="">4</SPAN>&nbsp;2.4.<SPAN LANG=""> Notation for the three
design dimensions </SPAN>of the BEACH conceptual model</FONT></FONT></P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">The BEACH conceptual
model can be used as the basis to structure architectures and
applications for ubiquitous computing and roomware environments.
Figure 4-2.4 suggests a graphical notation that can be used in design
diagrams to denote the position of classes within the design
dimensions of the conceptual model. This aids developers in
understanding the design of a ubiquitous computing application.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">In favor of being
applicable to a wide range of applications and architectures, the
model specifies a coarse-grained structure at a high level of
abstraction. Thereby, the conceptual model leaves much freedom for
application developers and architects to choose approaches
appropriate for the problem at hand. Foremost, the conceptual model
does not impose a restricted set of <I>architectural styles</I>
[[Jacobson-OOSE], [Groupware-Architectures]]. Rather, many
architectural styles can be used to implement the model. The same is
true for the <I>distribution architecture</I>
[[Groupware-Architectures]]. Depending on the constraints of the
platform and requirements in terms of collaboration, an arbitrary
distribution architecture can be selected.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">To show how the
BEACH conceptual model can be applied, the next sections presents the
BEACH software framework and a sample application that was built
using the framework.</P>
<P CLASS="western" STYLE="margin-bottom: 0.11cm">[### again some
stuff removed ###]</P>
<H1 CLASS="western">3References</H1>
<P STYLE="margin-left: 0.5cm; text-indent: -0.5cm; margin-bottom: 0cm">
<FONT FACE="Times, serif"><FONT SIZE=2 STYLE="font-size: 9pt">[{}]</FONT></FONT></P>
<DIV ID="sdfootnote1">
	<P CLASS="sdfootnote-western"><A CLASS="sdfootnotesym" NAME="sdfootnote1sym" HREF="#sdfootnote1anc">1</A>
	Of course, this is a simplified view on the research areas,
	focussing on their contributions relevant within the context of this
	paper.</P>
</DIV>
<DIV ID="sdfootnote2">
	<P CLASS="sdfootnote-western"><A CLASS="sdfootnotesym" NAME="sdfootnote2sym" HREF="#sdfootnote2anc">2</A>
	However, using detected context to trigger functionality always has
	the danger of relying on misinterpreted information, which can be
	very annoying for users.</P>
</DIV>
<DIV TYPE=FOOTER>
	<P STYLE="text-indent: 0.4cm; margin-top: 0.77cm; margin-bottom: 0cm">
	<FONT FACE="Times, serif">Submitted to JSS, special issue on
	UbiTools	v3.1, 04.11.02	<SDFIELD TYPE=PAGE SUBTYPE=RANDOM FORMAT=PAGE>11</SDFIELD>/<SDFIELD TYPE=DOCSTAT SUBTYPE=PAGE FORMAT=ARABIC>11</SDFIELD></FONT></P>
</DIV>
</BODY>
</HTML>